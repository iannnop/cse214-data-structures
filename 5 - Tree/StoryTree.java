import java.io.PrintWriter;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.zip.DataFormatException;

/**
 *  The <code>StoryTree</code> class represents the primary data structure for the <code>Zork</code> game.
 *
 * @author Jun-Yi Wu
 *  <p>email: jun-yi.wu@stonybrook.edu</p>
 *  <p>Stony Brook ID: 112277356</p>
 *  <p>CSE 214: Recitation 03</p>
 */

public class StoryTree {
    /**
     * Dummy root of the tree. This <code>StoryTreeNode</code> is the true root and should never be selected by the user
     */
    private StoryTreeNode root;
    /**
     * A reference to the currently selected <code>StoryTreeNode</code> in the tree. cursor should never be null.
     */
    private StoryTreeNode cursor;
    /**
     * The current state of the game which indicates whether the game has ended and the result of the game.
     */
    private GameState state;

    /**
     * Default constructor for the <code>StoryTree</code> class
     */
    public StoryTree() {
        root = new StoryTreeNode("root", "Hello, Welcome to Zork!");
        root.setPosition("root");
        cursor = root;
    }

    /**
     * Constructor with <code>option</code> and <code>message</code> parameters
     * @param option
     *  Option of the node
     * @param message
     *  Message of the node
     */
    public StoryTree(String option, String message) {
        root = new StoryTreeNode("root", "Hello, Welcome to Zork!");
        root.setPosition("root");
        StoryTreeNode node = new StoryTreeNode(option, message);
        node.setPosition("1");
        root.setLeftChild(node);
        cursor = node;
    }

    /**
     * Reads in a text file describing a StoryTree
     * @param filename
     *  Name of the file to read from
     * @return
     *  A new StoryTree generated by the passed in text file
     * @throws IllegalArgumentException
     *  if <code>filename</code> is empty or null
     * @throws DataFormatException
     *  if the file contained data is inconsistent with the expected data format
     */
    public static StoryTree readTree(String filename) throws IllegalArgumentException, DataFormatException {
        if (filename==null||filename.equals(""))
            throw new IllegalArgumentException();
        StoryTree tree = new StoryTree();
        File story = new File(filename);
        try {
            Scanner fileIn = new Scanner(story);
            while (fileIn.hasNextLine()) {
                String data = fileIn.nextLine();
                if (!data.matches("^\\d(-\\d)* \\| (.+) \\| (.+)$"))
                    throw new DataFormatException();
                String[] nodeParam = data.split(" \\| ");
                String[] path = nodeParam[0].split("-");
                if (tree.cursor==tree.root) {
                    StoryTreeNode node = new StoryTreeNode(nodeParam[1],nodeParam[2]);
                    node.setPosition("1");
                    tree.cursor.setLeftChild(node);
                    tree.resetCursor();
                    continue;
                }
                for (int i=1; i<path.length;i++) {
                    try {
                        tree.selectChild(path[i]);
                    } catch (NodeNotPresentException e) {
                        try {
                            tree.addChild(nodeParam[1], nodeParam[2]);
                        } catch (TreeFullException tfe) {
                            System.out.println("TreeFullException");
                        }
                    }
                }
                tree.resetCursor();
            }
            fileIn.close();
        } catch (FileNotFoundException e) {
            System.out.println("File not found.\n");
            System.out.println("Creating empty tree...");
            StoryTreeNode node = new StoryTreeNode("option","message");
            node.setPosition("1");
            tree.cursor.setLeftChild(node);
            tree.resetCursor();
        }
        return tree;
    }

    /**
     * Saves a <code>StoryTree</code> to the indicated file using the specified data format
     * @param filename
     *  Name of the file to write to
     * @param tree
     *  A reference to the tree to save to the indicated file
     * @throws IllegalArgumentException
     *  If filename is empty or null, or if the tree is null
     */
    public static void saveTree(String filename, StoryTree tree) throws IllegalArgumentException {
        if (filename==null||filename.equals(""))
            throw new IllegalArgumentException();
        tree.resetCursor();
        File story = new File(filename);
        try {
            PrintWriter fileOut = new PrintWriter(story);
            tree.preorderSave(tree.cursor, fileOut);
            fileOut.close();
        } catch (FileNotFoundException e) {
            System.out.println("An error has occurred.");
        }
    }

    /**
     * Getter method for the current game state of the <code>StoryTree</code>
     * @return
     *  the <code>GameState</code> of the cursor
     */
    public GameState getGameState() {
        state = cursor.isWinningNode() ? GameState.GAME_OVER_WIN :
          cursor.isLosingNode() ? GameState.GAME_OVER_LOSE :
          GameState.GAME_NOT_OVER;
        return state;
    }

    /**
     * Getter method for the position of the cursor
     * @return
     *  position of the cursor
     */
    public String getCursorPosition() { return cursor.getPosition(); }

    /**
     * Getter method for the message of the cursor
     * @return
     *  message of the cursor
     */
    public String getCursorMessage() { return cursor.getMessage(); }

    /**
     * Getter method for the option of the cursor
     * @return
     *  option of the cursor
     */
    public String getCursorOption() { return cursor.getOption(); }

    /**
     * Gets a set of positions and options of the cursor's children
     * @return
     *  an array of <code>String</code> pairs - (option, position) for each immediate child of the cursor
     */
    public String[][] getOptions() {
        String[][] options = new String[getNumChildren()][2];
        StoryTreeNode[] children = {cursor.getLeftChild(),cursor.getMiddleChild(),cursor.getRightChild()};
        for (int i=0; i<options.length; i++) {
                options[i][0] = children[i].getPosition();
                options[i][1] = children[i].getOption();
        }
        return options;
    }

    /**
     * Setter method for the cursor's message
     * @param message
     *  new message for the cursor
     */
    public void setCursorMessage(String message) { cursor.setMessage(message);}

    /**
     * Setter method for the cursor's option
     * @param option
     *  new option for the cursor
     */
    public void setCursorOption(String option) { cursor.setOption(option); }

    /**
     * Resets the cursor to the root node
     */
    public void resetCursor() { cursor = root.getLeftChild(); }

    /**
     * Selects the child with the name indicated by position relative to the cursor
     * @param position
     *  The position string of the child to select
     * @throws IllegalArgumentException
     *  if position is empty or null
     * @throws NodeNotPresentException
     *  Node with indicated position was not found
     */
    public void selectChild(String position) throws IllegalArgumentException, NodeNotPresentException {
        if (position==null||position.equals(""))
            throw new IllegalArgumentException();
        StoryTreeNode child;
        child = position.equals("1") ? cursor.getLeftChild() : position.equals("2") ? cursor.getMiddleChild() :
          position.equals("3") ? cursor.getRightChild() : null;
        if (child==null)
            throw new NodeNotPresentException("Node with indicated position variable was not found.");
        else
            cursor = child;
    }

    /**
     * Adds a new child under the current cursor, with given option and message
     * @param option
     *  The new String to set as the option of the new child
     * @param message
     *  The new String to set as the message of the new child
     * @throws IllegalArgumentException
     *  If either option or message is null or empty
     * @throws TreeFullException
     *  If all three child spots are full
     */
    public void addChild(String option, String message) throws IllegalArgumentException, TreeFullException {
        if (option==null||message==null||option.equals("")||message.equals(""))
            throw new IllegalArgumentException();
        if (cursor.getLeftChild()!=null&&cursor.getMiddleChild()!=null&&cursor.getRightChild()!=null)
            throw new TreeFullException("All three child spots are already full.");
        StoryTreeNode child = new StoryTreeNode(option,message);
        if (cursor.getLeftChild()==null) {
            cursor.setLeftChild(child);
            child.setPosition(cursor.getPosition()+"-1");
        }
        else if (cursor.getMiddleChild()==null) {
            cursor.setMiddleChild(child);
            child.setPosition(cursor.getPosition()+"-2");
        }
        else if (cursor.getRightChild()==null) {
            cursor.setRightChild(child);
            child.setPosition(cursor.getPosition()+"-3");
        }
    }

    /**
     * Removes an immediate child under the current cursor. This method implicitly removes the entire subtree where the
     * child is a root.
     * @param position
     *  String indicating the position of the child to be removed
     * @return
     *  A reference to the child removed (along with it's attached subtree)
     * @throws NodeNotPresentException
     *  Node with the indicated position variable was not found
     */
    public StoryTreeNode removeChild(String position) throws NodeNotPresentException {
        StoryTreeNode child;
        if (getNumChildren()<Integer.parseInt(position)) {
            throw new NodeNotPresentException("Node with indicated position variable cannot be found.");
        }
        else if (position.equals("1")) {
            child = cursor.getLeftChild();
            cursor.setLeftChild(cursor.getMiddleChild());
            cursor.setMiddleChild(cursor.getRightChild());
            cursor.setRightChild(null);
        }
        else if (position.equals("2")) {
            child = cursor.getMiddleChild();
            cursor.setMiddleChild(cursor.getRightChild());
            cursor.setRightChild(null);
        }
        else if (position.equals("3")) {
            child = cursor.getRightChild();
            cursor.setRightChild(null);
        }
        else
            throw new NodeNotPresentException("Node with indicated position variable cannot be found.");
        preorderFixPosition(cursor,cursor.getPosition());
        return child;
    }

    /**
     * Helper method for the <code>saveTree</code> function. Saves the tree into a file using preorder traversal
     * @param node
     *  Node to be saved to the file
     * @param fileOut
     *  PrintWriter that produces an output stream
     */
    public void preorderSave(StoryTreeNode node, PrintWriter fileOut) {
        if (node==null)
            return;
        fileOut.printf("%s | %s | %s%n", node.getPosition(),node.getOption(),node.getMessage());
        preorderSave(node.getLeftChild(), fileOut);
        preorderSave(node.getMiddleChild(), fileOut);
        preorderSave(node.getRightChild(), fileOut);
    }

    /**
     * Helper method for the <code>removeChild</code> function which adjusts the position variable of the cursor and
     * all of its descendants so that the children of the tree are left-aligned.
     * @param node
     *  Node whose position variable will be corrected
     * @param position
     *  new corrected position String that is relative to the parent's updated position
     */
    public void preorderFixPosition(StoryTreeNode node, String position) {
        if (node==null)
            return;
        node.setPosition(position);
        preorderFixPosition(node.getLeftChild(),node.getPosition()+"-1");
        preorderFixPosition(node.getMiddleChild(),node.getPosition()+"-2");
        preorderFixPosition(node.getRightChild(),node.getPosition()+"-3");
    }

    /**
     * Editing function for the user to traverse up the tree to return to the parent of the cursor
     */
    public void returnToParent() {
        String[] path = cursor.getPosition().split("-");
        cursor = root;
        for (int i=0; i<path.length-1; i++) {
            try {
                selectChild(path[i]);
            } catch (NodeNotPresentException e) {
                System.out.println("Node with indicated position variable cannot be found.");
            }
        }
    }

    /**
     * Helper method for the <code>winProbability</code> function that counts the total number of leaves of a tree or
     * subtree given a node
     * @param node
     *  Node to be checked for the total number of leaves
     * @return
     *  Recursively returns the total number of leaves of a node's children
     */
    public double totalLeaves(StoryTreeNode node) {
        if (node==null)
            return 0.0;
        else if (node.isLeaf())
            return 1.0;
        else
            return totalLeaves(node.getLeftChild())+totalLeaves(node.getMiddleChild())+
              totalLeaves(node.getRightChild());
    }

    /**
     * Helper method for the <code>winProbability</code> function that counts the total number of winning nodes
     * of a tree or subtree given a node.
     * @param node
     *  Node to be checked for the total number of winning leaves
     * @return
     *  Recursively returns the total number of winning leaves of a node's children
     */
    public double totalWinning(StoryTreeNode node) {
        if (node==null)
            return 0.0;
        if (node.isWinningNode())
            return 1.0;
        else
            return totalWinning(node.getLeftChild())+totalWinning(node.getMiddleChild())+
              totalWinning(node.getRightChild());
    }

    /**
     * Calculates the probability of ending the game with a winning <code>GameState</code> from the current position
     * of the game at the cursor
     * @return
     *  a double value representing the probability of a win (totalWinning/totalLeaves)
     */
    public double winProbability() {
        return totalWinning(cursor)/totalLeaves(cursor);
    }

    /**
     * Getter method for the number of children of the cursor
     * @return
     *  the number of children that the currently selected node has
     */
    public int getNumChildren() {
        int numChildren=0;
        StoryTreeNode[] children = {cursor.getLeftChild(),cursor.getMiddleChild(),cursor.getRightChild()};
        for (StoryTreeNode child : children)
            if (child!=null)
                numChildren++;
        return numChildren;
    }
}
